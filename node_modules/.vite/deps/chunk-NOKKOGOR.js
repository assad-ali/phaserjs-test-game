// node_modules/phaser3-rex-plugins/plugins/utils/input/CursorKeys.js
var Key = Phaser.Input.Keyboard.Key;
var KeyCodes = Phaser.Input.Keyboard.KeyCodes;
var CursorKeys = class {
  constructor(scene) {
    this.cursorKeys = {
      up: new Key(scene, KeyCodes.UP),
      down: new Key(scene, KeyCodes.DOWN),
      left: new Key(scene, KeyCodes.LEFT),
      right: new Key(scene, KeyCodes.RIGHT)
    };
    this.noKeyDown = true;
  }
  shutdown(fromScene) {
    for (var key in this.cursorKeys) {
      this.cursorKeys[key].destroy();
    }
    this.cursorKeys = void 0;
  }
  destroy(fromScene) {
    shutdown(fromScene);
  }
  createCursorKeys() {
    return this.cursorKeys;
  }
  setKeyState(keyName, isDown) {
    var key = this.cursorKeys[keyName];
    if (!key.enabled) {
      return this;
    }
    if (isDown) {
      this.noKeyDown = false;
    }
    if (key.isDown !== isDown) {
      FakeEvent.timeStamp = Date.now();
      FakeEvent.keyCode = key.keyCode;
      if (isDown) {
        key.onDown(FakeEvent);
      } else {
        key.onUp(FakeEvent);
      }
    }
    return this;
  }
  clearAllKeysState() {
    this.noKeyDown = true;
    for (var keyName in this.cursorKeys) {
      this.setKeyState(keyName, false);
    }
    return this;
  }
  getKeyState(keyName) {
    return this.cursorKeys[keyName];
  }
  get upKeyDown() {
    return this.cursorKeys.up.isDown;
  }
  get downKeyDown() {
    return this.cursorKeys.down.isDown;
  }
  get leftKeyDown() {
    return this.cursorKeys.left.isDown;
  }
  get rightKeyDown() {
    return this.cursorKeys.right.isDown;
  }
  get anyKeyDown() {
    return !this.noKeyDown;
  }
};
var FakeEvent = {
  timeStamp: 0,
  keyCode: 0,
  altKey: false,
  ctrlKey: false,
  shiftKey: false,
  metaKey: false,
  location: 0
};
var CursorKeys_default = CursorKeys;

// node_modules/phaser3-rex-plugins/plugins/utils/math/RadToDeg.js
var RAD_TO_DEG = 180 / Math.PI;
var RadToDeg = function(radians) {
  return radians * RAD_TO_DEG;
};
var RadToDeg_default = RadToDeg;

// node_modules/phaser3-rex-plugins/plugins/utils/math/angle/angletodirections/Const.js
var Const_default = {
  "up&down": 0,
  "left&right": 1,
  "4dir": 2,
  "8dir": 3
};

// node_modules/phaser3-rex-plugins/plugins/utils/math/angle/angletodirections/AngleToDirections.js
var AngleToDirections = function(angle, dirMode, out) {
  if (out === void 0) {
    out = {};
  } else if (out === true) {
    out = globOut;
  }
  out.left = false;
  out.right = false;
  out.up = false;
  out.down = false;
  angle = (angle + 360) % 360;
  switch (dirMode) {
    case 0:
      if (angle < 180) {
        out.down = true;
      } else {
        out.up = true;
      }
      break;
    case 1:
      if (angle > 90 && angle <= 270) {
        out.left = true;
      } else {
        out.right = true;
      }
      break;
    case 2:
      if (angle > 45 && angle <= 135) {
        out.down = true;
      } else if (angle > 135 && angle <= 225) {
        out.left = true;
      } else if (angle > 225 && angle <= 315) {
        out.up = true;
      } else {
        out.right = true;
      }
      break;
    case 3:
      if (angle > 22.5 && angle <= 67.5) {
        out.down = true;
        out.right = true;
      } else if (angle > 67.5 && angle <= 112.5) {
        out.down = true;
      } else if (angle > 112.5 && angle <= 157.5) {
        out.down = true;
        out.left = true;
      } else if (angle > 157.5 && angle <= 202.5) {
        out.left = true;
      } else if (angle > 202.5 && angle <= 247.5) {
        out.left = true;
        out.up = true;
      } else if (angle > 247.5 && angle <= 292.5) {
        out.up = true;
      } else if (angle > 292.5 && angle <= 337.5) {
        out.up = true;
        out.right = true;
      } else {
        out.right = true;
      }
      break;
  }
  return out;
};
var globOut = {};
var AngleToDirections_default = AngleToDirections;

// node_modules/phaser3-rex-plugins/plugins/utils/input/VectorToCursorKeys.js
var GetValue = Phaser.Utils.Objects.GetValue;
var GetDist = Phaser.Math.Distance.Between;
var GetAngle = Phaser.Math.Angle.Between;
var VectorToCursorKeys = class extends CursorKeys_default {
  constructor(scene, config) {
    super(scene);
    this.resetFromJSON(config);
  }
  resetFromJSON(o) {
    if (this.start == void 0) {
      this.start = { x: 0, y: 0 };
    }
    if (this.end == void 0) {
      this.end = { x: 0, y: 0 };
    }
    this._enable = void 0;
    this.setEnable(GetValue(o, "enable", true));
    this.setMode(GetValue(o, "dir", "8dir"));
    this.setDistanceThreshold(GetValue(o, "forceMin", 16));
    var startX = GetValue(o, "start.x", null);
    var startY = GetValue(o, "start.y", null);
    var endX = GetValue(o, "end.x", null);
    var endY = GetValue(o, "end.y", null);
    this.setVector(startX, startY, endX, endY);
    return this;
  }
  toJSON() {
    return {
      enable: this.enable,
      dir: this.dirMode,
      forceMin: this.forceMin,
      start: {
        x: this.start.x,
        y: this.start.y
      },
      end: {
        x: this.end.x,
        y: this.end.y
      }
    };
  }
  setMode(m) {
    if (typeof m === "string") {
      m = Const_default[m];
    }
    this.dirMode = m;
    return this;
  }
  get enable() {
    return this._enable;
  }
  set enable(e) {
    if (this._enable === e) {
      return;
    }
    if (!e) {
      this.clearVector();
    }
    this._enable = e;
    return this;
  }
  setEnable(e) {
    if (e === void 0) {
      e = true;
    }
    this.enable = e;
    return this;
  }
  toggleEnable() {
    this.setEnable(!this.enable);
    return this;
  }
  setDistanceThreshold(d) {
    if (d < 0) {
      d = 0;
    }
    this.forceMin = d;
    return this;
  }
  clearVector() {
    this.start.x = 0;
    this.start.y = 0;
    this.end.x = 0;
    this.end.y = 0;
    this.clearAllKeysState();
    return this;
  }
  setVector(x0, y0, x1, y1) {
    if (!this.enable) {
      return this;
    }
    if (x0 === null) {
      this.clearVector();
      return this;
    }
    if (x1 === void 0) {
      x1 = x0;
      x0 = 0;
      y1 = y0;
      y0 = 0;
    }
    this.start.x = x0;
    this.start.y = y0;
    this.end.x = x1;
    this.end.y = y1;
    if (this.forceMin > 0 && this.force < this.forceMin) {
      this.clearVector();
      return this;
    }
    this.noKeyDown = true;
    var dirStates = AngleToDirections_default(this.angle, this.dirMode, true);
    for (var dir in dirStates) {
      this.setKeyState(dir, dirStates[dir]);
    }
    return this;
  }
  get forceX() {
    return this.end.x - this.start.x;
  }
  get forceY() {
    return this.end.y - this.start.y;
  }
  get force() {
    return GetDist(this.start.x, this.start.y, this.end.x, this.end.y);
  }
  get rotation() {
    return GetAngle(this.start.x, this.start.y, this.end.x, this.end.y);
  }
  get angle() {
    return RadToDeg_default(this.rotation);
  }
  get octant() {
    var octant = 0;
    if (this.rightKeyDown) {
      octant = this.downKeyDown ? 45 : 0;
    } else if (this.downKeyDown) {
      octant = this.leftKeyDown ? 135 : 90;
    } else if (this.leftKeyDown) {
      octant = this.upKeyDown ? 225 : 180;
    } else if (this.upKeyDown) {
      octant = this.rightKeyDown ? 315 : 270;
    }
    return octant;
  }
};
var VectorToCursorKeys_default = VectorToCursorKeys;

// node_modules/phaser3-rex-plugins/plugins/utils/eventemitter/EventEmitterMethods.js
var EventEmitterMethods_default = {
  setEventEmitter(eventEmitter, EventEmitterClass) {
    if (EventEmitterClass === void 0) {
      EventEmitterClass = Phaser.Events.EventEmitter;
    }
    this._privateEE = eventEmitter === true || eventEmitter === void 0;
    this._eventEmitter = this._privateEE ? new EventEmitterClass() : eventEmitter;
    return this;
  },
  destroyEventEmitter() {
    if (this._eventEmitter && this._privateEE) {
      this._eventEmitter.shutdown();
    }
    return this;
  },
  getEventEmitter() {
    return this._eventEmitter;
  },
  on: function() {
    if (this._eventEmitter) {
      this._eventEmitter.on.apply(this._eventEmitter, arguments);
    }
    return this;
  },
  once: function() {
    if (this._eventEmitter) {
      this._eventEmitter.once.apply(this._eventEmitter, arguments);
    }
    return this;
  },
  off: function() {
    if (this._eventEmitter) {
      this._eventEmitter.off.apply(this._eventEmitter, arguments);
    }
    return this;
  },
  emit: function(event) {
    if (this._eventEmitter && event) {
      this._eventEmitter.emit.apply(this._eventEmitter, arguments);
    }
    return this;
  },
  addListener: function() {
    if (this._eventEmitter) {
      this._eventEmitter.addListener.apply(this._eventEmitter, arguments);
    }
    return this;
  },
  removeListener: function() {
    if (this._eventEmitter) {
      this._eventEmitter.removeListener.apply(this._eventEmitter, arguments);
    }
    return this;
  },
  removeAllListeners: function() {
    if (this._eventEmitter) {
      this._eventEmitter.removeAllListeners.apply(this._eventEmitter, arguments);
    }
    return this;
  },
  listenerCount: function() {
    if (this._eventEmitter) {
      return this._eventEmitter.listenerCount.apply(this._eventEmitter, arguments);
    }
    return 0;
  },
  listeners: function() {
    if (this._eventEmitter) {
      return this._eventEmitter.listeners.apply(this._eventEmitter, arguments);
    }
    return [];
  },
  eventNames: function() {
    if (this._eventEmitter) {
      return this._eventEmitter.eventNames.apply(this._eventEmitter, arguments);
    }
    return [];
  }
};

// node_modules/phaser3-rex-plugins/plugins/input/touchcursor/TouchCursor.js
var GetValue2 = Phaser.Utils.Objects.GetValue;
var CircleClass = Phaser.Geom.Circle;
var CircleContains = Phaser.Geom.Circle.Contains;
var TouchCursor = class extends VectorToCursorKeys_default {
  constructor(gameObject, config) {
    var scene = gameObject.scene;
    super(scene, config);
    var eventEmitter = GetValue2(config, "eventEmitter", void 0);
    var EventEmitterClass = GetValue2(config, "EventEmitterClass", void 0);
    this.setEventEmitter(eventEmitter, EventEmitterClass);
    this.scene = scene;
    this.mainCamera = scene.cameras.main;
    this.pointer = void 0;
    this.gameObject = gameObject;
    this.radius = GetValue2(config, "radius", 100);
    gameObject.setInteractive(new CircleClass(gameObject.displayOriginX, gameObject.displayOriginY, this.radius), CircleContains);
    this.boot();
  }
  resetFromJSON(o) {
    super.resetFromJSON(o);
    this.pointer = void 0;
    return this;
  }
  toJSON() {
    var o = super.toJSON();
    o.radius = this.radius;
    return o;
  }
  boot() {
    this.gameObject.on("pointerdown", this.onKeyDownStart, this);
    this.gameObject.on("pointerover", this.onKeyDownStart, this);
    this.scene.input.on("pointermove", this.onKeyDown, this);
    this.scene.input.on("pointerup", this.onKeyUp, this);
    this.gameObject.once("destroy", this.onParentDestroy, this);
  }
  shutdown(fromScene) {
    if (!this.scene) {
      return;
    }
    this.scene.input.off("pointermove", this.onKeyDown, this);
    this.scene.input.off("pointerup", this.onKeyUp, this);
    this.destroyEventEmitter();
    this.scene = void 0;
    this.mainCamera = void 0;
    this.pointer = void 0;
    this.gameObject = void 0;
    super.shutdown();
  }
  destroy(fromScene) {
    this.shutdown(fromScene);
  }
  onParentDestroy(parent, fromScene) {
    this.destroy(fromScene);
  }
  onKeyDownStart(pointer) {
    if (!pointer.isDown || this.pointer !== void 0) {
      return;
    }
    this.pointer = pointer;
    this.onKeyDown(pointer);
  }
  onKeyDown(pointer) {
    if (this.pointer !== pointer) {
      return;
    }
    var camera = pointer.camera;
    if (!camera) {
      return;
    }
    var gameObject = this.gameObject;
    var worldXY = this.end;
    if (camera !== this.mainCamera) {
      camera.getWorldPoint(pointer.x, pointer.y, worldXY);
    } else {
      worldXY.x = pointer.worldX;
      worldXY.y = pointer.worldY;
    }
    this.setVector(gameObject.x + camera.scrollX, gameObject.y + camera.scrollY, worldXY.x, worldXY.y);
    this.emit("update");
  }
  onKeyUp(pointer) {
    if (this.pointer !== pointer) {
      return;
    }
    this.pointer = void 0;
    this.clearVector();
    this.emit("update");
  }
};
Object.assign(TouchCursor.prototype, EventEmitterMethods_default);
var TouchCursor_default = TouchCursor;

// node_modules/phaser3-rex-plugins/plugins/touchcursor.js
var touchcursor_default = TouchCursor_default;

// node_modules/phaser3-rex-plugins/plugins/input/virtualjoystick/VirtualJoyStick.js
var GetValue3 = Phaser.Utils.Objects.GetValue;
var VirtualJoyStick = class {
  constructor(scene, config) {
    if (config === void 0) {
      config = {};
    }
    var eventEmitter = GetValue3(config, "eventEmitter", void 0);
    var EventEmitterClass = GetValue3(config, "EventEmitterClass", void 0);
    this.setEventEmitter(eventEmitter, EventEmitterClass);
    config.eventEmitter = this.getEventEmitter();
    this.scene = scene;
    this.base = void 0;
    this.thumb = void 0;
    this.touchCursor = void 0;
    this.setRadius(GetValue3(config, "radius", 100));
    this.addBase(GetValue3(config, "base", void 0), config);
    this.addThumb(GetValue3(config, "thumb", void 0));
    var x = GetValue3(config, "x", 0);
    var y = GetValue3(config, "y", 0);
    this.base.setPosition(x, y);
    this.thumb.setPosition(x, y);
    if (GetValue3(config, "fixed", true)) {
      this.setScrollFactor(0);
    }
    this.boot();
  }
  destroy() {
    this.destroyEventEmitter();
    this.base.destroy();
    this.thumb.destroy();
    this.scene = void 0;
    this.base = void 0;
    this.thumb = void 0;
    this.touchCursor = void 0;
  }
  createCursorKeys() {
    return this.touchCursor.createCursorKeys();
  }
  get forceX() {
    return this.touchCursor.forceX;
  }
  get forceY() {
    return this.touchCursor.forceY;
  }
  get force() {
    return this.touchCursor.force;
  }
  get rotation() {
    return this.touchCursor.rotation;
  }
  get angle() {
    return this.touchCursor.angle;
  }
  get up() {
    return this.touchCursor.upKeyDown;
  }
  get down() {
    return this.touchCursor.downKeyDown;
  }
  get left() {
    return this.touchCursor.leftKeyDown;
  }
  get right() {
    return this.touchCursor.rightKeyDown;
  }
  get noKey() {
    return this.touchCursor.noKeyDown;
  }
  get pointerX() {
    return this.touchCursor.end.x;
  }
  get pointerY() {
    return this.touchCursor.end.y;
  }
  get pointer() {
    return this.touchCursor.pointer;
  }
  setPosition(x, y) {
    this.x = x;
    this.y = y;
    return this;
  }
  set x(x) {
    this.base.x = x;
    this.thumb.x = x;
  }
  set y(y) {
    this.base.y = y;
    this.thumb.y = y;
  }
  get x() {
    return this.base.x;
  }
  get y() {
    return this.base.y;
  }
  setVisible(visible) {
    this.visible = visible;
    return this;
  }
  toggleVisible() {
    this.visible = !this.visible;
    return this;
  }
  get visible() {
    return this.base.visible;
  }
  set visible(visible) {
    this.base.visible = visible;
    this.thumb.visible = visible;
  }
  get enable() {
    return this.touchCursor.enable;
  }
  set enable(value) {
    this.touchCursor.setEnable(value);
  }
  setEnable(e) {
    if (e === void 0) {
      e = true;
    }
    this.enable = e;
    return this;
  }
  toggleEnable() {
    this.setEnable(!this.enable);
    return this;
  }
  setRadius(radius) {
    this.radius = radius;
    return this;
  }
  addBase(gameObject, config) {
    if (this.base) {
      this.base.destroy();
    }
    if (gameObject === void 0) {
      gameObject = this.scene.add.circle(0, 0, this.radius).setStrokeStyle(3, 255);
    }
    this.touchCursor = new touchcursor_default(gameObject, config);
    this.base = gameObject;
    return this;
  }
  addThumb(gameObject) {
    if (this.thumb) {
      this.thumb.destroy();
    }
    if (gameObject === void 0) {
      gameObject = this.scene.add.circle(0, 0, 40).setStrokeStyle(3, 65280);
    }
    this.thumb = gameObject;
    return this;
  }
  setScrollFactor(scrollFactor) {
    this.base.setScrollFactor(scrollFactor);
    this.thumb.setScrollFactor(scrollFactor);
    return this;
  }
  boot() {
    this.touchCursor.on("update", this.update, this);
  }
  update() {
    var touchCursor = this.touchCursor;
    var x = this.base.x;
    var y = this.base.y;
    if (touchCursor.anyKeyDown) {
      if (touchCursor.force > this.radius) {
        var rad = touchCursor.rotation;
        x += Math.cos(rad) * this.radius;
        y += Math.sin(rad) * this.radius;
      } else {
        x += touchCursor.forceX;
        y += touchCursor.forceY;
      }
    }
    this.thumb.x = x;
    this.thumb.y = y;
    return this;
  }
};
Object.assign(VirtualJoyStick.prototype, EventEmitterMethods_default);
var VirtualJoyStick_default = VirtualJoyStick;

// node_modules/phaser3-rex-plugins/plugins/virtualjoystick.js
var virtualjoystick_default = VirtualJoyStick_default;

export {
  virtualjoystick_default
};
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2018 Photon Storm Ltd.
 * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
 */
//# sourceMappingURL=chunk-NOKKOGOR.js.map
